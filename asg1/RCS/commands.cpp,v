head	1.71;
access;
symbols;
locks;
comment	@// @;


1.71
date	2013.01.22.00.05.55;	author -;	state -;
branches;
next	1.70;

1.70
date	2013.01.21.23.03.04;	author -;	state -;
branches;
next	1.69;

1.69
date	2013.01.21.22.06.48;	author -;	state -;
branches;
next	1.68;

1.68
date	2013.01.21.21.18.05;	author -;	state -;
branches;
next	1.67;

1.67
date	2013.01.21.18.59.38;	author -;	state -;
branches;
next	1.66;

1.66
date	2013.01.21.18.23.17;	author -;	state -;
branches;
next	1.65;

1.65
date	2013.01.20.22.11.06;	author -;	state -;
branches;
next	1.64;

1.64
date	2013.01.20.22.08.29;	author -;	state -;
branches;
next	1.63;

1.63
date	2013.01.20.21.52.01;	author -;	state -;
branches;
next	1.62;

1.62
date	2013.01.20.21.47.26;	author -;	state -;
branches;
next	1.61;

1.61
date	2013.01.20.21.46.45;	author -;	state -;
branches;
next	1.60;

1.60
date	2013.01.20.21.45.15;	author -;	state -;
branches;
next	1.59;

1.59
date	2013.01.20.21.43.11;	author -;	state -;
branches;
next	1.58;

1.58
date	2013.01.20.21.42.53;	author -;	state -;
branches;
next	1.57;

1.57
date	2013.01.20.21.42.31;	author -;	state -;
branches;
next	1.56;

1.56
date	2013.01.20.21.42.13;	author -;	state -;
branches;
next	1.55;

1.55
date	2013.01.20.21.35.23;	author -;	state -;
branches;
next	1.54;

1.54
date	2013.01.20.21.24.25;	author -;	state -;
branches;
next	1.53;

1.53
date	2013.01.20.21.24.00;	author -;	state -;
branches;
next	1.52;

1.52
date	2013.01.20.00.34.47;	author -;	state -;
branches;
next	1.51;

1.51
date	2013.01.20.00.03.47;	author -;	state -;
branches;
next	1.50;

1.50
date	2013.01.19.20.40.29;	author -;	state -;
branches;
next	1.49;

1.49
date	2013.01.19.20.24.18;	author -;	state -;
branches;
next	1.48;

1.48
date	2013.01.18.23.13.41;	author -;	state -;
branches;
next	1.47;

1.47
date	2013.01.18.22.37.42;	author -;	state -;
branches;
next	1.46;

1.46
date	2013.01.18.20.58.31;	author -;	state -;
branches;
next	1.45;

1.45
date	2013.01.18.20.38.32;	author -;	state -;
branches;
next	1.44;

1.44
date	2013.01.18.20.33.36;	author -;	state -;
branches;
next	1.43;

1.43
date	2013.01.18.20.28.19;	author -;	state -;
branches;
next	1.42;

1.42
date	2013.01.18.20.25.33;	author -;	state -;
branches;
next	1.41;

1.41
date	2013.01.18.20.12.47;	author -;	state -;
branches;
next	1.40;

1.40
date	2013.01.18.20.12.08;	author -;	state -;
branches;
next	1.39;

1.39
date	2013.01.18.20.09.19;	author -;	state -;
branches;
next	1.38;

1.38
date	2013.01.18.19.57.23;	author -;	state -;
branches;
next	1.37;

1.37
date	2013.01.18.19.56.31;	author -;	state -;
branches;
next	1.36;

1.36
date	2013.01.18.19.55.22;	author -;	state -;
branches;
next	1.35;

1.35
date	2013.01.18.19.55.08;	author -;	state -;
branches;
next	1.34;

1.34
date	2013.01.18.19.44.50;	author -;	state -;
branches;
next	1.33;

1.33
date	2013.01.18.19.44.19;	author -;	state -;
branches;
next	1.32;

1.32
date	2013.01.18.19.39.27;	author -;	state -;
branches;
next	1.31;

1.31
date	2013.01.18.19.37.38;	author -;	state -;
branches;
next	1.30;

1.30
date	2013.01.18.19.32.11;	author -;	state -;
branches;
next	1.29;

1.29
date	2013.01.18.19.30.42;	author -;	state -;
branches;
next	1.28;

1.28
date	2013.01.18.19.29.12;	author -;	state -;
branches;
next	1.27;

1.27
date	2013.01.18.18.14.28;	author -;	state -;
branches;
next	1.26;

1.26
date	2013.01.18.17.37.26;	author -;	state -;
branches;
next	1.25;

1.25
date	2013.01.18.02.39.13;	author -;	state -;
branches;
next	1.24;

1.24
date	2013.01.18.02.04.14;	author -;	state -;
branches;
next	1.23;

1.23
date	2013.01.18.01.29.45;	author -;	state -;
branches;
next	1.22;

1.22
date	2013.01.18.01.06.27;	author -;	state -;
branches;
next	1.21;

1.21
date	2013.01.18.01.02.08;	author -;	state -;
branches;
next	1.20;

1.20
date	2013.01.18.01.01.28;	author -;	state -;
branches;
next	1.19;

1.19
date	2013.01.16.20.06.49;	author -;	state -;
branches;
next	1.18;

1.18
date	2013.01.16.20.02.32;	author -;	state -;
branches;
next	1.17;

1.17
date	2013.01.16.19.56.34;	author -;	state -;
branches;
next	1.16;

1.16
date	2013.01.16.19.22.16;	author -;	state -;
branches;
next	1.15;

1.15
date	2013.01.16.19.21.21;	author -;	state -;
branches;
next	1.14;

1.14
date	2013.01.16.19.20.49;	author -;	state -;
branches;
next	1.13;

1.13
date	2013.01.16.19.07.52;	author -;	state -;
branches;
next	1.12;

1.12
date	2013.01.16.19.06.53;	author -;	state -;
branches;
next	1.11;

1.11
date	2013.01.16.19.00.55;	author -;	state -;
branches;
next	1.10;

1.10
date	2013.01.16.18.53.08;	author -;	state -;
branches;
next	1.9;

1.9
date	2013.01.16.18.50.39;	author -;	state -;
branches;
next	1.8;

1.8
date	2013.01.16.18.26.15;	author -;	state -;
branches;
next	1.7;

1.7
date	2013.01.16.18.25.46;	author -;	state -;
branches;
next	1.6;

1.6
date	2013.01.16.18.05.07;	author -;	state -;
branches;
next	1.5;

1.5
date	2013.01.15.03.04.37;	author -;	state -;
branches;
next	1.4;

1.4
date	2013.01.14.21.10.56;	author -;	state -;
branches;
next	1.3;

1.3
date	2013.01.14.21.02.08;	author -;	state -;
branches;
next	1.2;

1.2
date	2013.01.14.20.41.00;	author -;	state -;
branches;
next	1.1;

1.1
date	2013.01.10.01.34.19;	author -;	state -;
branches;
next	;


desc
@@


1.71
log
@-
@
text
@
#include "commands.h"
#include "trace.h"

commands::commands(): map (commandmap()) {
   map["cat"    ] = fn_cat    ;
   map["cd"     ] = fn_cd     ;
   map["echo"   ] = fn_echo   ;
   map["exit"   ] = fn_exit   ;
   map["ls"     ] = fn_ls     ;
   map["lsr"    ] = fn_lsr    ;
   map["make"   ] = fn_make   ;
   map["mkdir"  ] = fn_mkdir  ;
   map["prompt" ] = fn_prompt ;
   map["pwd"    ] = fn_pwd    ;
   map["rm"     ] = fn_rm     ;
   map["#"      ] = fn_comment;
}

function commands::operator[] (const string& cmd) {
   return map[cmd];
}


/*
get_prompt:returns the string/char for the prompt
           from vector of string
*/
string get_prompt(const wordvec &words){
   string new_prompt;
   for(unsigned i =1; i<words.size(); i++){
      if( i == words.size()-1){
         new_prompt = new_prompt + words[i];
      }
      else{
         new_prompt = new_prompt + words[i] + " ";
      }
   }
   return new_prompt;
}

void fn_cat (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
   string line;
   if(words.size() == 1){
      throw yshell_exn("no files specified");
   }
   else{
      state.cat_file(words);
   }
}

void fn_cd (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
   string hold_dir;
   wordvec move_dir;
   if (words.size() == 1){
      state.cd_root();
   } else{
      for(unsigned i=1; i< words.size(); ++i){
         hold_dir += words.at(i);
      }
      move_dir = split(hold_dir,"/");
      state.cd_set_cwd(state,move_dir);
   }
}

void fn_echo (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
   for(unsigned i =1; i< words.size(); i++){
      cout << words[i] << " ";
   }
   cout << endl;
}

void fn_exit (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
   throw ysh_exit_exn ();
}

void fn_ls (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
   if(words.size() == 1){
      state.print_ls();
   } else {
      for(unsigned i =1; i< words.size(); ++i){
         state.path_ls(words[i]);
      }      
   }
}

void fn_lsr (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
}

void fn_make (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
   state.make_file(words);
}

void fn_mkdir (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
   state.make_dir(words);
}

void fn_prompt (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
   string newPrompt = get_prompt(words);
   state.set_prompt(newPrompt);
}

void fn_pwd (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
   state.print_pwd();
}

void fn_rm (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
   if(words.size() == 1){
      throw yshell_exn("no pathname specified");
   } else if(words[1] == "/"){
      throw yshell_exn("cannot rm " + words[1]); 
   } else{
      state.remove_inode(words);
   }
}

void fn_rmr (inode_state &state, const wordvec &words){
   TRACE ('c', state);
   TRACE ('c', words);
}
/*
 handles comments entered by the user
*/
void fn_comment(inode_state &state, const wordvec &words){
   TRACE('c', state);
   TRACE('c', words); 
}

int exit_status_message() {
   int exit_status = exit_status::get();
   cout << execname() << ": exit(" << exit_status << ")" << endl;
   return exit_status;
}


@


1.70
log
@-
@
text
@d25 4
a28 1

d143 3
a145 1

@


1.69
log
@-
@
text
@d88 3
a90 1
      state.path_ls(words[1]);      
@


1.68
log
@-
@
text
@d130 1
a130 1
      cout << "in rm"<<endl;
@


1.67
log
@-
@
text
@d125 7
@


1.66
log
@-
@
text
@d63 1
a63 1
      state.cd_set_cwd(state.get_cwd(),move_dir);
@


1.65
log
@-
@
text
@d63 1
a63 1
      state.cd_set_cwd(move_dir);
@


1.64
log
@-
@
text
@d57 1
a57 1
      state.set_cwd;
@


1.63
log
@-
@
text
@d56 8
a63 2
   for(unsigned i=1; i< words.size(); ++i){
      hold_dir += words.at(i);
a64 3
   cout << hold_dir <<endl;
   move_dir = split(hold_dir,"/");
   cout << move_dir << endl;
@


1.62
log
@-
@
text
@a96 2
   //inode *the_cwd = state.get_cwd();
   //inode *file = (*the_cwd).mkfile(words[2]);
@


1.61
log
@-
@
text
@d56 1
a56 1
   for(unsigned i=0; i< words.size(); ++i){
@


1.60
log
@-
@
text
@d59 1
a59 1
   cout << hold_dir << endl;
@


1.59
log
@-
@
text
@d60 2
@


1.58
log
@-
@
text
@d65 1
a65 1
   for(int i =1; i< words.size(); i++){
@


1.57
log
@-
@
text
@d28 1
a28 1
   for(int i =1; i<words.size(); i++){
@


1.56
log
@-
@
text
@d56 1
a56 1
   for(int i=0; i< words.size(); ++i){
@


1.55
log
@-
@
text
@d54 6
@


1.54
log
@-
@
text
@d110 1
@


1.53
log
@-
@
text
@d124 1
a124 1
   TRACE('c', state); 
@


1.52
log
@-
@
text
@d17 1
d122 5
@


1.51
log
@-
@
text
@d46 1
a46 3
      for(int i=1; i<words.size(); i++){
         throw yshell_exn( words[i] +": no such file or directory");
      }
@


1.50
log
@-
@
text
@d98 1
@


1.49
log
@-
@
text
@d75 5
a79 1
   state.print_ls();
@


1.48
log
@-
@
text
@d75 1
a75 2
   
   //state.print_ls();
@


1.47
log
@-
@
text
@d75 2
a76 1
   state.print_ls();
@


1.46
log
@-
@
text
@d43 1
a43 4
      while(!cin.eof()){
         getline(cin,line);
         cout << line << endl;
      }
@


1.45
log
@-
@
text
@d89 3
a91 3
   inode *the_cwd = state.get_cwd();
   inode *file = (*the_cwd).mkfile(words[2]);
   state.make_file(file,words);
@


1.44
log
@-
@
text
@d90 2
a91 2
   inode file = (*the_cwd).mkfile(words[2]);
   state.make_file(&file,words);
@


1.43
log
@-
@
text
@d91 1
a91 1
   state.make_file(file,words);
@


1.42
log
@-
@
text
@d90 1
a90 1
   inode *file = (*the_cwd).mkfile(words[2]);
@


1.41
log
@-
@
text
@d90 1
a90 1
   inode *file = the_cwd->mkfile(words[2]);
@


1.40
log
@-
@
text
@d90 1
a90 1
   inode *file = the_cwd->mkdir(words[2]);
@


1.39
log
@-
@
text
@d89 2
a90 1
   inode *file = state.get_cwd()->mkfile(words[2]);
@


1.38
log
@-
@
text
@d89 1
a89 1
   inode *file = state.get_file(words[2]);
@


1.37
log
@-
@
text
@d89 1
a89 1
   inode *file = &state.get_file(words[2]);
@


1.36
log
@-
@
text
@d89 1
a89 1
   inode *file = state.get_file(words[2]);
@


1.35
log
@-
@
text
@d89 1
a89 1
   inode *file = state.get_file(word[2]);
@


1.34
log
@-
@
text
@d89 1
a89 1
   inode *file = mkfile(words[2]);
@


1.33
log
@-
@
text
@d90 1
a90 1
   state.make_file(words);
@


1.32
log
@-
@
text
@d89 1
@


1.31
log
@-
@
text
@d89 1
a89 1
   state.make_file(file,words);
@


1.30
log
@-
@
text
@a88 1
   inode *file = mkfile(words[2]);
@


1.29
log
@-
@
text
@d89 1
a89 1
   inode *file = &mkfile(words[2]);
@


1.28
log
@-
@
text
@d89 2
a90 2
   inode *file = mkfile(words[2]);
   state.makefile(file,words);
@


1.27
log
@-
@
text
@d89 2
a90 1
   state.make_file(words);
@


1.26
log
@-
@
text
@d89 1
a89 1
   
@


1.25
log
@-
@
text
@d89 1
a89 1
   inode file(FILE_INODE);
@


1.24
log
@-
@
text
@d89 1
@


1.23
log
@-
@
text
@d78 1
@


1.22
log
@-
@
text
@a77 1
   cout << state.inode_nr()<< endl;
@


1.21
log
@-
@
text
@d78 1
a78 1
   cout << state.cwd->get_inode_nr() << endl;
@


1.20
log
@-
@
text
@d78 1
a78 1
   cout << state.get_inode_nr() << endl;
@


1.19
log
@-
@
text
@d23 2
d78 1
@


1.18
log
@-
@
text
@d47 3
a49 1
      throw yshell_exn( words[1] +": no such file or directory");
@


1.17
log
@-
@
text
@d47 1
a47 1
      cout << "no file/directory "+ words[2] << endl;
@


1.16
log
@-
@
text
@d47 1
a47 1
      throw yshell_exn("no file/directory "+ words[2]);
@


1.15
log
@-
@
text
@d41 4
a44 4
        while(!cin.eof()){
           getline(cin,line);
            cout << line << endl;
        }
d47 1
a47 1
	throw yshell_exn("no file/directory "+ words[2]);
@


1.14
log
@-
@
text
@d47 1
a47 1
	throw yshell_exn("no file/directory "+ word[2]);
@


1.13
log
@-
@
text
@d46 3
@


1.12
log
@-
@
text
@d41 1
a41 1
	while(!cin.eof()){
d43 2
a44 2
	   cout << line << endl;
	}
a45 1
   
@


1.11
log
@-
@
text
@d41 1
a41 1
	while(cin){
a42 3
           if( line == EOF){
              break;
           }
@


1.10
log
@-
@
text
@d39 1
a39 1
   string hold = "";
d41 3
a43 3
	for(;;){
	   cin >> hold >> endl;
           if( hold == EOF){
d46 1
a46 1
	   cout << hold << endl;
@


1.9
log
@-
@
text
@d39 1
a39 1
   string hold;
@


1.8
log
@-
@
text
@d39 10
@


1.7
log
@-
@
text
@d26 1
a26 1
      if( i == word.size()-1){
@


1.6
log
@-
@
text
@d26 6
a31 1
      new_prompt = new_prompt + words[i] + " ";
@


1.5
log
@-
@
text
@d23 8
d80 2
@


1.4
log
@-
@
text
@d26 1
@


1.3
log
@-
@
text
@d39 1
a39 1
      cout << endl;
@


1.2
log
@-
@
text
@d37 1
a37 1
	cout << words[i] << " ";
d39 1
a39 1
	cout << endl;
@


1.1
log
@-
@
text
@d36 4
@
